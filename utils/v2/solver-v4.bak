/**
 * Sudoku Solver & Grader V4
 * Based on Sudoku Explainer (SE) logic and scoring.
 */

export type Bitmask = number; // Bits 1-9 (1 << 0 to 1 << 8)
export type BoardState = number[][]; // 9x9 array of 0-9

export interface StepAction {
    technique: string;
    difficulty: number;
    explanation: string;
    // For single-digit placements or eliminations
    row?: number;
    col?: number;
    val?: number;
    highlights: { row: number; col: number; type: 'target' | 'elimination' | 'hint'; val?: number }[];
    highlightCells?: { row: number; col: number; type: 'target' | 'elimination' | 'hint'; val?: number }[]; // Alias for V2 compatibility
    nodes?: AICNode[]; // For chains
}

export interface AICNode {
    r: number;
    c: number;
    v: number;
}

export const ALL_CANDIDATES = 0x1FF; // Binary 111111111

export class GridModelV4 {
    public cells: Int8Array;
    public candidates: Int16Array;
    private rowSolved: Int16Array;
    private colSolved: Int16Array;
    private boxSolved: Int16Array;

    constructor(input: string | number[][]) {
        this.cells = new Int8Array(81);
        this.candidates = new Int16Array(81).fill(ALL_CANDIDATES);
        this.rowSolved = new Int16Array(9).fill(0);
        this.colSolved = new Int16Array(9).fill(0);
        this.boxSolved = new Int16Array(9).fill(0);

        if (typeof input === 'string') {
            this.parseString(input);
        } else if (Array.isArray(input[0])) {
            this.parseBoard(input as number[][]);
        } else {
            this.parse1DArray(input as any as number[]);
        }
    }

    private parseString(str: string): void {
        const cleanStr = str.replace(/[^0-9.]/g, '.');
        for (let i = 0; i < 81; i++) {
            const char = cleanStr[i];
            if (char !== '.' && char !== '0') {
                this.setCellValue(i, parseInt(char, 10));
            }
        }
        this.updateCandidates();
    }

    private parseBoard(board: number[][]): void {
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                if (board[r][c] !== 0 && board[r][c] !== undefined) {
                    this.setCellValue(r * 9 + c, board[r][c]);
                }
            }
        }
        this.updateCandidates();
    }

    private parse1DArray(array: number[]): void {
        for (let i = 0; i < 81; i++) {
            if (array[i] !== 0 && array[i] !== undefined) {
                this.setCellValue(i, array[i]);
            }
        }
        this.updateCandidates();
    }

    public setCellValue(index: number, val: number): void {
        const row = Math.floor(index / 9);
        const col = index % 9;
        const box = Math.floor(row / 3) * 3 + Math.floor(col / 3);

        this.cells[index] = val;
        this.candidates[index] = 0;

        const mask = 1 << (val - 1);
        this.rowSolved[row] |= mask;
        this.colSolved[col] |= mask;
        this.boxSolved[box] |= mask;

        // Incremental update for peers
        const peers = PEERS[index];
        for (let i = 0; i < peers.length; i++) {
            this.candidates[peers[i]] &= ~mask;
        }
    }

    public updateCandidates(): void {
        for (let i = 0; i < 81; i++) {
            if (this.cells[i] !== 0) continue;

            const row = Math.floor(i / 9);
            const col = i % 9;
            const box = Math.floor(row / 3) * 3 + Math.floor(col / 3);

            const solvedInPeers = this.rowSolved[row] | this.colSolved[col] | this.boxSolved[box];
            this.candidates[i] &= ~solvedInPeers;
        }
    }

    public applyStep(step: StepAction): void {
        // If it's a placement
        if (step.val !== undefined && step.row !== undefined && step.col !== undefined && step.highlights.some(h => h.type === 'target')) {
            this.setCellValue(step.row * 9 + step.col, step.val);
        } else {
            // It's eliminations
            for (const h of step.highlights) {
                if (h.type === 'elimination') {
                    const idx = h.row * 9 + h.col;
                    const digitToEliminate = h.val !== undefined ? h.val : step.val;
                    if (digitToEliminate !== undefined && digitToEliminate !== -1) {
                        this.candidates[idx] &= ~(1 << (digitToEliminate - 1));
                    } else if (h.val === -1 && step.highlights.filter(hi => hi.type === 'hint').length > 0) {
                        // Naked Subset elimination: find which bits to remove based on hint cells
                        let mask = 0;
                        for (const hint of step.highlights.filter(hi => hi.type === 'hint')) {
                            mask |= this.candidates[hint.row * 9 + hint.col];
                        }
                        this.candidates[idx] &= ~mask;
                    }
                }
            }
        }
    }

    public isSolved(): boolean {
        return this.cells.every(c => c !== 0);
    }

    public clone(): GridModelV4 {
        const copy = Object.create(GridModelV4.prototype);
        copy.cells = new Int8Array(this.cells);
        copy.candidates = new Int16Array(this.candidates);
        copy.rowSolved = new Int16Array(this.rowSolved);
        copy.colSolved = new Int16Array(this.colSolved);
        copy.boxSolved = new Int16Array(this.boxSolved);
        return copy;
    }

    public static countSetBits(n: number): number {
        let count = 0;
        let temp = n;
        while (temp > 0) {
            temp &= (temp - 1);
            count++;
        }
        return count;
    }

    public static getVals(mask: number): number[] {
        const vals = [];
        for (let v = 1; v <= 9; v++) {
            if (mask & (1 << (v - 1))) vals.push(v);
        }
        return vals;
    }
}

/**
 * SE Scoring & Penalty Logic
 */

export function getChainLengthPenalty(length: number): number {
    if (length <= 4) return 0.0;

    let addedDifficulty = 0.0;
    let ceil = 4;
    let isOddStep = false;

    while (length > ceil) {
        addedDifficulty += 0.1;
        if (!isOddStep) {
            ceil = Math.floor(ceil * 3 / 2); // 1.5
        } else {
            ceil = Math.floor(ceil * 4 / 3); // 1.33
        }
        isOddStep = !isOddStep;
    }

    return Number(addedDifficulty.toFixed(1));
}

export const BASE_RATINGS: Record<string, number> = {
    "Last Digit": 1.0,
    "Hidden Single (Block)": 1.2,
    "Hidden Single (Line)": 1.5,
    "Direct Pointing": 1.7,
    "Pointing Pair": 2.1,
    "Naked Single": 2.3,
    "Claiming Pair": 2.6,
    "Naked Pair": 3.0,
    "X-Wing": 3.2,
    "Hidden Pair": 3.4,
    "Naked Triplet": 3.6,
    "Swordfish": 3.8,
    "Hidden Triplet": 4.0,
    "XY-Wing": 4.2,
    "XYZ-Wing": 4.4,
    "Unique Rectangle (Type 1)": 4.5,
    "Unique Rectangle (Type 2)": 4.6,
    "Unique Rectangle (Type 3)": 4.8,
    "Unique Rectangle (Type 4)": 4.5,
    "Naked Quad": 5.0,
    "Jellyfish": 5.2,
    "Hidden Quad": 5.4,
    "BUG Type 1": 5.6,
    "BUG Type 2": 5.7,
    "Aligned Pair Exclusion": 6.2,
    "Bidirectional Cycle": 6.5,
    "Forcing X-Chain": 6.6,
    "Forcing Chain": 7.0,
    "Nishio Forcing Chain": 7.5,
    "Region Forcing Chain": 8.0,
    "Cell Forcing Chain": 8.2,
    "Dynamic Forcing Chain": 8.5,
    "Dynamic Forcing Chain (+)": 9.0
};

/**
 * Strategy Library
 */

export interface Strategy {
    find(grid: GridModelV4): StepAction | null;
}

// 1. Singles
export class HiddenSingleStrategy implements Strategy {
    find(grid: GridModelV4): StepAction | null {
        // Blocks first (1.2)
        for (let b = 0; b < 9; b++) {
            const res = this.checkHouse(grid, b + 18, "Hidden Single (Block)", 1.2);
            if (res) return res;
        }
        // Lines (1.5)
        for (let i = 0; i < 18; i++) {
            const tech = "Hidden Single (Line)";
            const res = this.checkHouse(grid, i, tech, 1.5);
            if (res) return res;
        }
        return null;
    }

    private checkHouse(grid: GridModelV4, houseIdx: number, technique: string, difficulty: number): StepAction | null {
        const houseCells = getHouseCells(houseIdx);
        for (let v = 1; v <= 9; v++) {
            const mask = 1 << (v - 1);
            let count = 0;
            let lastIdx = -1;
            for (const idx of houseCells) {
                if (grid.candidates[idx] & mask) {
                    count++;
                    lastIdx = idx;
                }
            }
            if (count === 1) {
                const r = Math.floor(lastIdx / 9);
                const c = lastIdx % 9;
                return {
                    technique,
                    difficulty,
                    explanation: `${technique}: ${v} in house ${houseIdx + 1} can only be at (${r + 1},${c + 1})`,
                    row: r, col: c, val: v,
                    highlights: [{ row: r, col: c, type: 'target', val: v }]
                };
            }
        }
        return null;
    }
}

export class NakedSingleStrategy implements Strategy {
    find(grid: GridModelV4): StepAction | null {
        for (let i = 0; i < 81; i++) {
            if (grid.cells[i] === 0 && GridModelV4.countSetBits(grid.candidates[i]) === 1) {
                const val = GridModelV4.getVals(grid.candidates[i])[0];
                const r = Math.floor(i / 9);
                const c = i % 9;
                return {
                    technique: "Naked Single",
                    difficulty: 2.3,
                    explanation: `Naked Single: (${r + 1},${c + 1}) has only one candidate: ${val}`,
                    row: r, col: c, val: val,
                    highlights: [{ row: r, col: c, type: 'target', val }]
                };
            }
        }
        return null;
    }
}

// Helper: House definition
// 0-8: Rows, 9-17: Cols, 18-26: Boxes
export const HOUSES: number[][] = Array(27).fill(0).map(() => []);
for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
        const idx = r * 9 + c;
        const b = Math.floor(r / 3) * 3 + Math.floor(c / 3);
        HOUSES[r].push(idx);            // Row
        HOUSES[c + 9].push(idx);        // Col
        HOUSES[b + 18].push(idx);       // Box
    }
}

export function getHouseCells(idx: number): number[] {
    return HOUSES[idx];
}

// 2. Intersections
export class PointingStrategy implements Strategy {
    find(grid: GridModelV4): StepAction | null {
        for (let b = 0; b < 9; b++) {
            const boxCells = HOUSES[b + 18];
            for (let v = 1; v <= 9; v++) {
                const mask = 1 << (v - 1);
                const positions = boxCells.filter(idx => grid.candidates[idx] & mask);
                if (positions.length >= 2 && positions.length <= 3) {
                    const rows = new Set(positions.map(p => Math.floor(p / 9)));
                    const cols = new Set(positions.map(p => p % 9));

                    if (rows.size === 1) {
                        const r = Array.from(rows)[0];
                        if (r === undefined) continue;
                        const houseRow = HOUSES[r];
                        const elims = houseRow.filter(idx => !boxCells.includes(idx) && (grid.candidates[idx] & mask));
                        if (elims.length > 0) {
                            return {
                                technique: "Pointing Pair",
                                difficulty: 2.1,
                                explanation: `Pointing Pair: ${v} in box ${b + 1} restricted to row ${r + 1}`,
                                val: v,
                                highlights: [
                                    ...positions.map(p => ({ row: Math.floor(p / 9), col: p % 9, type: 'hint' as const })),
                                    ...elims.map(idx => ({ row: Math.floor(idx / 9), col: idx % 9, type: 'elimination' as const, val: v }))
                                ]
                            };
                        }
                    }
                    if (cols.size === 1) {
                        const c = Array.from(cols)[0];
                        if (c === undefined) continue;
                        const houseCol = HOUSES[c + 9];
                        const elims = houseCol.filter(idx => !boxCells.includes(idx) && (grid.candidates[idx] & mask));
                        if (elims.length > 0) {
                            return {
                                technique: "Pointing Pair",
                                difficulty: 2.1,
                                explanation: `Pointing Pair: ${v} in box ${b + 1} restricted to col ${c + 1}`,
                                val: v,
                                highlights: [
                                    ...positions.map(p => ({ row: Math.floor(p / 9), col: p % 9, type: 'hint' as const })),
                                    ...elims.map(idx => ({ row: Math.floor(idx / 9), col: idx % 9, type: 'elimination' as const, val: v }))
                                ]
                            };
                        }
                    }
                }
            }
        }
        return null;
    }
}

export class ClaimingStrategy implements Strategy {
    find(grid: GridModelV4): StepAction | null {
        // Line-Box reduction: If in a line, all occurrences of v are in one box,
        // remove v from the rest of that box.
        for (let h = 0; h < 18; h++) {
            const lineCells = HOUSES[h];
            for (let v = 1; v <= 9; v++) {
                const mask = 1 << (v - 1);
                const positions = lineCells.filter(idx => grid.candidates[idx] & mask);
                if (positions.length >= 2 && positions.length <= 3) {
                    const boxes = new Set(positions.map(p => Math.floor(Math.floor(p / 9) / 3) * 3 + Math.floor((p % 9) / 3)));
                    if (boxes.size === 1) {
                        const b = Array.from(boxes)[0];
                        if (b === undefined) continue;
                        const boxCells = HOUSES[b + 18];
                        const elims = boxCells.filter(idx => !lineCells.includes(idx) && (grid.candidates[idx] & mask));
                        if (elims.length > 0) {
                            return {
                                technique: "Claiming Pair",
                                difficulty: 2.6,
                                explanation: `Claiming Pair: ${v} in line ${h < 9 ? 'row' : 'col'} ${h % 9 + 1} restricted to box ${b + 1}`,
                                val: v,
                                highlights: [
                                    ...positions.map(p => ({ row: Math.floor(p / 9), col: p % 9, type: 'hint' as const })),
                                    ...elims.map(e => ({ row: Math.floor(e / 9), col: e % 9, type: 'elimination' as const, val: v }))
                                ]
                            };
                        }
                    }
                }
            }
        }
        return null;
    }
}

export class HiddenSubsetStrategy implements Strategy {
    constructor(private n: number) { }
    find(grid: GridModelV4): StepAction | null {
        const difficulty = [0, 0, 3.4, 4.0, 5.4][this.n];
        const names = ["", "", "Hidden Pair", "Hidden Triplet", "Hidden Quad"];

        for (let h = 0; h < 27; h++) {
            const houseCells = HOUSES[h];
            const emptyCells = houseCells.filter(idx => grid.cells[idx] === 0);
            if (emptyCells.length <= this.n) continue;

            const digitsInHouse = new Set<number>();
            for (const idx of emptyCells) {
                const vals = GridModelV4.getVals(grid.candidates[idx]);
                for (const v of vals) digitsInHouse.add(v);
            }
            if (digitsInHouse.size <= this.n) continue;

            const combinations = getCombinations(Array.from(digitsInHouse), this.n);
            for (const comboDigits of combinations) {
                const mask = comboDigits.reduce((acc, v) => acc | (1 << (v - 1)), 0);
                const cellsWithDigits = emptyCells.filter(idx => (grid.candidates[idx] & mask) !== 0);

                if (cellsWithDigits.length === this.n) {
                    // Hidden Subset found! 
                    // Any OTHER candidates in these cells can be removed.
                    const elims: { row: number, col: number, type: 'elimination', val: number }[] = [];
                    for (const idx of cellsWithDigits) {
                        const otherMask = grid.candidates[idx] & ~mask;
                        if (otherMask !== 0) {
                            const otherVals = GridModelV4.getVals(otherMask);
                            for (const ov of otherVals) {
                                elims.push({ row: Math.floor(idx / 9), col: idx % 9, type: 'elimination' as const, val: ov });
                            }
                        }
                    }

                    if (elims.length > 0) {
                        return {
                            technique: names[this.n],
                            difficulty,
                            explanation: `${names[this.n]}: ${comboDigits.join(',')} hidden in cells`,
                            highlights: [
                                ...cellsWithDigits.map(p => ({ row: Math.floor(p / 9), col: p % 9, type: 'hint' as const })),
                                ...elims
                            ]
                        };
                    }
                }
            }
        }
        return null;
    }
}

// 3. Subsets (Naked Pairs for now)
export class NakedSubsetStrategy implements Strategy {
    constructor(private n: number) { }
    find(grid: GridModelV4): StepAction | null {
        const difficulty = [0, 0, 3.0, 3.6, 5.0][this.n];
        const names = ["", "", "Naked Pair", "Naked Triplet", "Naked Quad"];

        for (let h = 0; h < 27; h++) {
            const houseCells = HOUSES[h];
            const emptyCells = houseCells.filter(idx => grid.cells[idx] === 0);
            if (emptyCells.length <= this.n) continue;

            const combinations = getCombinations(emptyCells, this.n);
            for (const combo of combinations) {
                let mask = 0;
                for (const idx of combo) {
                    mask |= grid.candidates[idx];
                }
                if (GridModelV4.countSetBits(mask) === this.n) {
                    // Possible elimination
                    const elims = emptyCells.filter(idx => !combo.includes(idx) && (grid.candidates[idx] & mask));
                    if (elims.length > 0) {
                        const highlights: any[] = combo.map(p => ({ row: Math.floor(p / 9), col: p % 9, type: 'hint' as const }));

                        for (const e of elims) {
                            const eRow = Math.floor(e / 9);
                            const eCol = e % 9;
                            const eliminatedDigits = GridModelV4.getVals(grid.candidates[e] & mask);
                            for (const d of eliminatedDigits) {
                                highlights.push({ row: eRow, col: eCol, type: 'elimination', val: d });
                            }
                        }

                        return {
                            technique: names[this.n],
                            difficulty,
                            explanation: `${names[this.n]}: ${GridModelV4.getVals(mask).join(',')} locked in cells`,
                            highlights
                        };
                    }
                }
            }
        }
        return null;
    }
}

function getCombinations<T>(array: T[], k: number): T[][] {
    const results: T[][] = [];
    function f(start: number, combo: T[]) {
        if (combo.length === k) {
            results.push([...combo]);
            return;
        }
        for (let i = start; i < array.length; i++) {
            combo.push(array[i]);
            f(i + 1, combo);
            combo.pop();
        }
    }
    f(0, []);
    return results;
}

// 4. Fish (X-Wing, Swordfish, Jellyfish)
export class FishStrategy implements Strategy {
    constructor(private n: number) { }
    find(grid: GridModelV4): StepAction | null {
        const difficulty = [0, 0, 3.2, 3.8, 5.2][this.n];
        const names = ["", "", "X-Wing", "Swordfish", "Jellyfish"];

        for (let v = 1; v <= 9; v++) {
            const mask = 1 << (v - 1);
            // Check rows
            const res = this.findFishInUnits(grid, v, mask, 0, 9, difficulty, names[this.n]);
            if (res) return res;
            // Check cols
            const res2 = this.findFishInUnits(grid, v, mask, 9, 18, difficulty, names[this.n]);
            if (res2) return res2;
        }
        return null;
    }

    private findFishInUnits(grid: GridModelV4, v: number, vMask: number, startH: number, endH: number, difficulty: number, technique: string): StepAction | null {
        const unitsWithV = [];
        for (let h = startH; h < endH; h++) {
            const cells = HOUSES[h].filter(idx => grid.candidates[idx] & vMask);
            if (cells.length >= 2 && cells.length <= this.n) {
                unitsWithV.push({ h, cells });
            }
        }

        if (unitsWithV.length < this.n) return null;

        const combos = getCombinations(unitsWithV, this.n);
        for (const combo of combos) {
            const allCells = combo.flatMap(u => u.cells);
            const secondaryIndices = new Set(allCells.map(idx => startH === 0 ? idx % 9 : Math.floor(idx / 9)));

            if (secondaryIndices.size === this.n) {
                // Potential Fish!
                const coverUnits = Array.from(secondaryIndices).map(idx => startH === 0 ? idx + 9 : idx);
                const elims = [];
                for (const hIdx of coverUnits) {
                    const house = HOUSES[hIdx];
                    for (const idx of house) {
                        if (!allCells.includes(idx) && (grid.candidates[idx] & vMask)) {
                            elims.push(idx);
                        }
                    }
                }

                if (elims.length > 0) {
                    return {
                        technique,
                        difficulty,
                        explanation: `${technique} on ${v}`,
                        val: v,
                        highlights: [
                            ...allCells.map(idx => ({ row: Math.floor(idx / 9), col: idx % 9, type: 'hint' as const })),
                            ...elims.map(idx => ({ row: Math.floor(idx / 9), col: idx % 9, type: 'elimination' as const, val: v }))
                        ]
                    };
                }
            }
        }
        return null;
    }
}

// 5. Wings
export class XYWingStrategy implements Strategy {
    find(grid: GridModelV4): StepAction | null {
        const bivalueCells: number[] = [];
        for (let i = 0; i < 81; i++) {
            if (grid.cells[i] === 0 && GridModelV4.countSetBits(grid.candidates[i]) === 2) {
                bivalueCells.push(i);
            }
        }

        for (const pivot of bivalueCells) {
            const pivotVals = GridModelV4.getVals(grid.candidates[pivot]); // [A, B]
            const peers = getPeers(pivot).filter(p => bivalueCells.includes(p));

            for (let i = 0; i < peers.length; i++) {
                for (let j = i + 1; j < peers.length; j++) {
                    const p1 = peers[i];
                    const p2 = peers[j];
                    if (sees(p1, p2)) continue; // Pincers must not see each other

                    const v1 = GridModelV4.getVals(grid.candidates[p1]); // [A, C]
                    const v2 = GridModelV4.getVals(grid.candidates[p2]); // [B, C]

                    // Check if they share one value each with pivot and one with each other
                    const shared1 = pivotVals.filter(v => v1.includes(v));
                    const shared2 = pivotVals.filter(v => v2.includes(v));
                    if (shared1.length === 1 && shared2.length === 1 && shared1[0] !== shared2[0]) {
                        const C1 = v1.filter(v => v !== shared1[0])[0];
                        const C2 = v2.filter(v => v !== shared2[0])[0];
                        if (C1 === C2) {
                            const elimDigit = C1;
                            const elims = getCommonPeers(p1, p2).filter(idx => (grid.candidates[idx] & (1 << (elimDigit - 1))));
                            if (elims.length > 0) {
                                return {
                                    technique: "XY-Wing",
                                    difficulty: 4.2,
                                    explanation: `XY-Wing: pivot (${Math.floor(pivot / 9) + 1},${pivot % 9 + 1}) pincers (${Math.floor(p1 / 9) + 1},${p1 % 9 + 1}) and (${Math.floor(p2 / 9) + 1},${p2 % 9 + 1})`,
                                    val: elimDigit,
                                    highlights: [
                                        { row: Math.floor(pivot / 9), col: pivot % 9, type: 'hint' },
                                        { row: Math.floor(p1 / 9), col: p1 % 9, type: 'hint' },
                                        { row: Math.floor(p2 / 9), col: p2 % 9, type: 'hint' },
                                        ...elims.map(idx => ({ row: Math.floor(idx / 9), col: idx % 9, type: 'elimination' as const, val: elimDigit }))
                                    ]
                                };
                            }
                        }
                    }
                }
            }
        }
        return null;
    }
}

export class XYZWingStrategy implements Strategy {
    find(grid: GridModelV4): StepAction | null {
        const bivalueCells: number[] = [];
        const trivalueCells: number[] = [];
        for (let i = 0; i < 81; i++) {
            if (grid.cells[i] === 0) {
                const count = GridModelV4.countSetBits(grid.candidates[i]);
                if (count === 2) bivalueCells.push(i);
                else if (count === 3) trivalueCells.push(i);
            }
        }

        for (const pivot of trivalueCells) {
            const pivotVals = GridModelV4.getVals(grid.candidates[pivot]); // [A, B, C]
            const bivaluePeers = getPeers(pivot).filter(p => bivalueCells.includes(p));
            if (bivaluePeers.length < 2) continue;

            const combos = getCombinations(bivaluePeers, 2);
            for (const [p1, p2] of combos) {
                const v1 = GridModelV4.getVals(grid.candidates[p1]);
                const v2 = GridModelV4.getVals(grid.candidates[p2]);

                // Pivot [A,B,C], Pincer1 [A,C], Pincer2 [B,C]
                // All three share C.
                const allShared = pivotVals.filter(v => v1.includes(v) && v2.includes(v));
                if (allShared.length === 1) {
                    const C = allShared[0];
                    const A = v1.find(v => v !== C);
                    const B = v2.find(v => v !== C);
                    if (A && B && A !== B && pivotVals.includes(A) && pivotVals.includes(B)) {
                        // XYZ-Wing found! Eliminations in cells seen by ALL THREE (pivot, p1, p2)
                        const elims = getCommonPeers(pivot, p1).filter(idx => getPeers(p2).includes(idx) && (grid.candidates[idx] & (1 << (C - 1))));
                        if (elims.length > 0) {
                            return {
                                technique: "XYZ-Wing",
                                difficulty: 4.4,
                                explanation: `XYZ-Wing: pivot (${Math.floor(pivot / 9) + 1},${pivot % 9 + 1}) pincers (${Math.floor(p1 / 9) + 1},${p1 % 9 + 1}) and (${Math.floor(p2 / 9) + 1},${p2 % 9 + 1})`,
                                val: C,
                                highlights: [
                                    { row: Math.floor(pivot / 9), col: pivot % 9, type: 'hint' },
                                    { row: Math.floor(p1 / 9), col: p1 % 9, type: 'hint' },
                                    { row: Math.floor(p2 / 9), col: p2 % 9, type: 'hint' },
                                    ...elims.map(idx => ({ row: Math.floor(idx / 9), col: idx % 9, type: 'elimination' as const, val: C }))
                                ]
                            };
                        }
                    }
                }
            }
        }
        return null;
    }
}

export class UniqueRectangleStrategy implements Strategy {
    find(grid: GridModelV4): StepAction | null {
        const bivalueCells = [];
        for (let i = 0; i < 81; i++) {
            if (grid.cells[i] === 0 && GridModelV4.countSetBits(grid.candidates[i]) === 2) {
                bivalueCells.push(i);
            }
        }

        const combos = getCombinations(bivalueCells, 3);
        for (const [c1, c2, c3] of combos) {
            const m1 = grid.candidates[c1];
            if (grid.candidates[c2] !== m1 || grid.candidates[c3] !== m1) continue;

            const r1 = Math.floor(c1 / 9), col1 = c1 % 9;
            const r2 = Math.floor(c2 / 9), col2 = c2 % 9;
            const r3 = Math.floor(c3 / 9), col3 = c3 % 9;

            let r4, col4;
            if (r1 === r2) {
                r4 = r3;
                if (col1 === col3) col4 = col2;
                else if (col2 === col3) col4 = col1;
                else continue;
            } else if (r1 === r3) {
                r4 = r2;
                if (col1 === col2) col4 = col3;
                else if (col2 === col3) col4 = col1;
                else continue;
            } else if (r2 === r3) {
                r4 = r1;
                if (col2 === col1) col4 = col3;
                else if (col3 === col1) col4 = col2;
                else continue;
            } else continue;

            const c4 = r4 * 9 + col4;
            if (grid.cells[c4] !== 0) continue;

            const m4 = grid.candidates[c4];
            if (m4 === m1) continue;
            if ((m4 & m1) === m1) {
                const vals = GridModelV4.getVals(m1);
                const val1 = vals[0];
                const val2 = vals[1];
                const elims = [];
                if (grid.candidates[c4] & (1 << (val1 - 1))) elims.push({ row: r4, col: col4, type: 'elimination' as const, val: val1 });
                if (grid.candidates[c4] & (1 << (val2 - 1))) elims.push({ row: r4, col: col4, type: 'elimination' as const, val: val2 });

                if (elims.length > 0) {
                    return {
                        technique: "Unique Rectangle (Type 1)",
                        difficulty: 4.5,
                        explanation: `Unique Rectangle (Type 1) at (${r1 + 1},${col1 + 1}), (${r2 + 1},${col2 + 1}), (${r3 + 1},${col3 + 1}), (${r4 + 1},${col4 + 1})`,
                        highlights: [
                            { row: r1, col: col1, type: 'hint' },
                            { row: r2, col: col2, type: 'hint' },
                            { row: r3, col: col3, type: 'hint' },
                            ...elims
                        ]
                    };
                }
            }
        }
        return null;
    }
}

export class BUGType1Strategy implements Strategy {
    find(grid: GridModelV4): StepAction | null {
        const emptyCells = [];
        for (let i = 0; i < 81; i++) {
            if (grid.cells[i] === 0) emptyCells.push(i);
        }

        const trivalue = emptyCells.filter(idx => GridModelV4.countSetBits(grid.candidates[idx]) === 3);
        const bivalue = emptyCells.filter(idx => GridModelV4.countSetBits(grid.candidates[idx]) === 2);

        if (trivalue.length === 1 && bivalue.length === emptyCells.length - 1) {
            const idx = trivalue[0];
            const vals = GridModelV4.getVals(grid.candidates[idx]);
            for (const v of vals) {
                const mask = 1 << (v - 1);
                const r = Math.floor(idx / 9), c = idx % 9;
                const b = Math.floor(r / 3) * 3 + Math.floor(c / 3);

                const rCount = HOUSES[r].filter(ci => grid.candidates[ci] & mask).length;
                const cCount = HOUSES[c + 9].filter(ci => grid.candidates[ci] & mask).length;
                const bCount = HOUSES[b + 18].filter(ci => grid.candidates[ci] & mask).length;

                if (rCount === 3 && cCount === 3 && bCount === 3) {
                    return {
                        technique: "BUG Type 1",
                        difficulty: 5.6,
                        explanation: `BUG Type 1: (${r + 1},${c + 1}) must be ${v}`,
                        row: r, col: c, val: v,
                        highlights: [{ row: r, col: c, type: 'target', val: v }]
                    };
                }
            }
        }
        return null;
    }
}

export class CellForcingStrategy implements Strategy {
    find(grid: GridModelV4): StepAction | null {
        // PASS 1: Bivalue Cells (Priority)
        // We want to find Bivalue Contradictions (7.0) or Bivalue Common Elims (8.0) first.
        // Contradiction (7.0) is checked before Common Elim (8.0) to prioritize simplicity.
        for (let i = 0; i < 81; i++) {
            if (grid.cells[i] !== 0) continue;
            const vals = GridModelV4.getVals(grid.candidates[i]);
            if (vals.length !== 2) continue; // Skip non-bivalue

            // 1. Shallow Contradiction check (7.0) - Unit Propagation Only
            for (const v of vals) {
                const elims = this.getEliminationsForAssumption(grid, i, v);
                if (elims[0] === -1) {
                    return {
                        technique: "Contradiction Forcing Chain",
                        difficulty: 7.0, // Shallow Contradiction
                        explanation: `Contradiction (Propagated): Cell (${Math.floor(i / 9) + 1},${i % 9 + 1}) cannot be ${v}`,
                        highlights: [
                            { row: Math.floor(i / 9), col: i % 9, type: 'hint' },
                            { row: Math.floor(i / 9), col: i % 9, type: 'elimination', val: v }
                        ]
                    };
                }
            }

            // 2. Common Elimination check (8.0) - Consensus after Propagation
            // Note: We already computed getEliminationsForAssumption above, could optimize but redundant call is safe for now.
            // Actually, we need the outputs.
            // Let's optimize:
            const branchElims = vals.map(v => this.getEliminationsForAssumption(grid, i, v));
            // Note: If any branch elims was -1, we would have returned 7.0 above.
            // So we assume here NO branch crashed immediately.

            const commonElims: any[] = [];
            for (let j = 0; j < 81; j++) {
                for (let v = 1; v <= 9; v++) {
                    const mask = 1 << (v - 1);
                    let eliminatedInAll = true;
                    for (const bElim of branchElims) {
                        if (bElim[0] === -1) continue; // Should not happen given step 1
                        if (!(bElim[j] & mask)) {
                            eliminatedInAll = false;
                            break;
                        }
                    }
                    if (eliminatedInAll) {
                        commonElims.push({ row: Math.floor(j / 9), col: j % 9, type: 'elimination' as const, val: v });
                    }
                }
            }

            if (commonElims.length > 0) {
                return {
                    technique: "Cell Forcing Chain",
                    difficulty: 8.0,
                    explanation: `Cell Forcing Chain on (${Math.floor(i / 9) + 1},${i % 9 + 1}) with candidates ${vals.join(',')}`,
                    highlights: [
                        { row: Math.floor(i / 9), col: i % 9, type: 'hint' },
                        ...commonElims
                    ]
                };
            }

            // 3. Deep Contradiction check (8.0) - Full Backtracking
            for (const v of vals) {
                const nextGrid = grid.clone();
                nextGrid.setCellValue(i, v);
                if (SudokuSolverV4.countSolutions(nextGrid.cells.join('').split('').map(Number)) === 0) {
                    return {
                        technique: "Contradiction Forcing Chain (Deep)",
                        difficulty: 8.0, // Deep Contradiction
                        explanation: `Contradiction (Deep): Cell (${Math.floor(i / 9) + 1},${i % 9 + 1}) cannot be ${v}`,
                        highlights: [
                            { row: Math.floor(i / 9), col: i % 9, type: 'hint' },
                            { row: Math.floor(i / 9), col: i % 9, type: 'elimination', val: v }
                        ]
                    };
                }
            }
        }

        // PASS 2: Multi-value Cells (3-4)
        for (let i = 0; i < 81; i++) {
            if (grid.cells[i] !== 0) continue;
            const vals = GridModelV4.getVals(grid.candidates[i]);
            if (vals.length < 3 || vals.length > 4) continue; // Skip bivalue (already checked) and >4 (too complex)

            // 1. Shallow Contradiction check (7.0) - Unit Propagation Only
            for (const v of vals) {
                const elims = this.getEliminationsForAssumption(grid, i, v);
                if (elims[0] === -1) {
                    return {
                        technique: "Contradiction Forcing Chain",
                        difficulty: 7.0, // Shallow Multi-value is still 7.0? Or 7.5? Let's try 7.0.
                        explanation: `Contradiction (Propagated): Cell (${Math.floor(i / 9) + 1},${i % 9 + 1}) cannot be ${v}`,
                        highlights: [
                            { row: Math.floor(i / 9), col: i % 9, type: 'hint' },
                            { row: Math.floor(i / 9), col: i % 9, type: 'elimination', val: v }
                        ]
                    };
                }
            }

            // 2. Common Elimination check (8.0)
            // Reuse the elims from shallow check
            const branchElims = vals.map(v => this.getEliminationsForAssumption(grid, i, v));
            const commonElims: any[] = [];

            for (let j = 0; j < 81; j++) {
                for (let v = 1; v <= 9; v++) {
                    const mask = 1 << (v - 1);
                    let eliminatedInAll = true;
                    for (const bElim of branchElims) {
                        if (bElim[0] === -1) continue;
                        if (!(bElim[j] & mask)) {
                            eliminatedInAll = false;
                            break;
                        }
                    }
                    if (eliminatedInAll) {
                        commonElims.push({ row: Math.floor(j / 9), col: j % 9, type: 'elimination' as const, val: v });
                    }
                }
            }

            if (commonElims.length > 0) {
                return {
                    technique: "Cell Forcing Chain",
                    difficulty: 8.0,
                    explanation: `Cell Forcing Chain on (${Math.floor(i / 9) + 1},${i % 9 + 1}) with candidates ${vals.join(',')}`,
                    highlights: [
                        { row: Math.floor(i / 9), col: i % 9, type: 'hint' },
                        ...commonElims
                    ]
                };
            }

            // 3. Deep Contradiction check (8.0)
            for (const v of vals) {
                const nextGrid = grid.clone();
                nextGrid.setCellValue(i, v);
                if (SudokuSolverV4.countSolutions(nextGrid.cells.join('').split('').map(Number)) === 0) {
                    return {
                        technique: "Contradiction Forcing Chain (Deep)",
                        difficulty: 8.0,
                        explanation: `Contradiction (Deep): Cell (${Math.floor(i / 9) + 1},${i % 9 + 1}) cannot be ${v}`,
                        highlights: [
                            { row: Math.floor(i / 9), col: i % 9, type: 'hint' },
                            { row: Math.floor(i / 9), col: i % 9, type: 'elimination', val: v }
                        ]
                    };
                }
            }
        }
        return null;
    }

    private getEliminationsForAssumption(grid: GridModelV4, idx: number, val: number): Int16Array {
        const tempGrid = grid.clone();
        tempGrid.setCellValue(idx, val);
        tempGrid.updateCandidates();

        const simpleStrats: Strategy[] = [
            new HiddenSingleStrategy(),
            new NakedSingleStrategy(),
            new PointingStrategy(),
            new ClaimingStrategy(),
            new NakedSubsetStrategy(2),
            new HiddenSubsetStrategy(2),
            new NakedSubsetStrategy(3),
            new HiddenSubsetStrategy(3)
        ];

        let changed = true;
        while (changed) {
            changed = false;
            for (const s of simpleStrats) {
                const step = s.find(tempGrid);
                if (step) {
                    tempGrid.applyStep(step);
                    // Check for contradiction
                    for (let k = 0; k < 81; k++) {
                        if (tempGrid.cells[k] === 0 && tempGrid.candidates[k] === 0) {
                            const fail = new Int16Array(81);
                            fail[0] = -1;
                            return fail;
                        }
                    }
                    changed = true;
                    break;
                }
            }
        }

        const result = new Int16Array(81);
        for (let j = 0; j < 81; j++) {
            if (grid.cells[j] === 0) {
                const originalCandidates = grid.candidates[j];
                let eliminated;
                if (tempGrid.cells[j] !== 0) {
                    // Cell was filled with a value. Everything EXCEPT that value was eliminated.
                    eliminated = originalCandidates & ~(1 << (tempGrid.cells[j] - 1));
                } else {
                    // Cell is still empty. Eliminated bits are those that were there but are gone now.
                    eliminated = originalCandidates & ~tempGrid.candidates[j];
                }
                result[j] = eliminated;
            }
        }
        return result;
    }
}

// 6. AIC Engine (SE 6.5+)
export class AICStrategy implements Strategy {
    find(grid: GridModelV4): StepAction | null {
        const strongLinks = this.getAllStrongLinks(grid);
        const linkMap = new Map<string, AICNode[]>();
        for (const link of strongLinks) {
            const k1 = nodeKey(link.from);
            const k2 = nodeKey(link.to);
            if (!linkMap.has(k1)) linkMap.set(k1, []);
            if (!linkMap.has(k2)) linkMap.set(k2, []);
            linkMap.get(k1)!.push(link.to);
            linkMap.get(k2)!.push(link.from);
        }

        const nodes = this.getAllNodes(grid);
        for (let limit = 4; limit <= 20; limit += 2) {
            for (const startNode of nodes) {
                const res = this.search(grid, startNode, true, [startNode], new Set([nodeKey(startNode)]), linkMap, limit);
                if (res) return res;
            }
        }
        return null;
    }

    private getAllNodes(grid: GridModelV4): AICNode[] {
        const nodes = [];
        for (let i = 0; i < 81; i++) {
            if (grid.cells[i] === 0) {
                const vals = GridModelV4.getVals(grid.candidates[i]);
                for (const v of vals) nodes.push({ r: Math.floor(i / 9), c: i % 9, v });
            }
        }
        return nodes;
    }

    private getAllStrongLinks(grid: GridModelV4): { from: AICNode, to: AICNode }[] {
        const links: { from: AICNode, to: AICNode }[] = [];
        for (let v = 1; v <= 9; v++) {
            const mask = 1 << (v - 1);
            for (let h = 0; h < 27; h++) {
                const cells = HOUSES[h].filter(idx => grid.candidates[idx] & mask);
                if (cells.length === 2) {
                    links.push({
                        from: { r: Math.floor(cells[0] / 9), c: cells[0] % 9, v },
                        to: { r: Math.floor(cells[1] / 9), c: cells[1] % 9, v }
                    });
                }
            }
        }
        for (let i = 0; i < 81; i++) {
            if (grid.cells[i] === 0 && GridModelV4.countSetBits(grid.candidates[i]) === 2) {
                const vals = GridModelV4.getVals(grid.candidates[i]);
                links.push({
                    from: { r: Math.floor(i / 9), c: i % 9, v: vals[0] },
                    to: { r: Math.floor(i / 9), c: i % 9, v: vals[1] }
                });
            }
        }
        return links;
    }

    private search(grid: GridModelV4, current: AICNode, nextIsStrong: boolean, path: AICNode[], visited: Set<string>, linkMap: Map<string, AICNode[]>, limit: number): StepAction | null {
        if (path.length > limit) return null;

        const start = path[0];
        const end = current;

        if (!nextIsStrong && path.length >= 4) {
            // Conclusion Rule 1: Same Digit, Different Cells -> Common Peers Elimination
            if (start.v === end.v && (start.r !== end.r || start.c !== end.c)) {
                const elims = getCommonPeers(start.r * 9 + start.c, end.r * 9 + end.c).filter(idx => (grid.candidates[idx] & (1 << (start.v - 1))));
                if (elims.length > 0) {
                    const penalty = getChainLengthPenalty(path.length);
                    const technique = "Forcing Chain";
                    const difficulty = 6.0 + penalty;
                    return {
                        technique,
                        difficulty: Number(difficulty.toFixed(1)),
                        explanation: `${technique} (Length ${path.length}) on ${start.v}`,
                        val: start.v,
                        nodes: [...path],
                        highlights: [
                            ...path.map(p => ({ row: p.r, col: p.c, type: 'hint' as const })),
                            ...elims.map(idx => ({ row: Math.floor(idx / 9), col: idx % 9, type: 'elimination' as const, val: start.v }))
                        ]
                    };
                }
            }

            // Conclusion Rule 2: Same Cell, Same Digits (V=off -> V=on) -> cell MUST be V
            if (start.v === end.v && start.r === end.r && start.c === end.c) {
                const technique = "Forcing Chain (Rule 2)";
                const difficulty = 6.5 + getChainLengthPenalty(path.length); // 6.5 base
                return {
                    technique,
                    difficulty: Number(difficulty.toFixed(1)),
                    explanation: `${technique}: (${start.r + 1},${start.c + 1}) must be ${start.v}`,
                    row: start.r, col: start.c, val: start.v,
                    nodes: [...path],
                    highlights: [
                        ...path.map(p => ({ row: p.r, col: p.c, type: 'hint' as const })),
                        { row: start.r, col: start.c, type: 'target', val: start.v }
                    ]
                };
            }

            // Conclusion Rule 3: Different cells in same house, same digit
            if (start.v === end.v) {
                const house = getCommonHouse(start.r * 9 + start.c, end.r * 9 + end.c);
                if (house !== -1) {
                    const houseCells = HOUSES[house];
                    const elims = houseCells.filter(idx => idx !== (start.r * 9 + start.c) && idx !== (end.r * 9 + end.c) && (grid.candidates[idx] & (1 << (start.v - 1))));
                    if (elims.length > 0) {
                        const technique = "Forcing Chain (Rule 3)";
                        const difficulty = 6.8 + getChainLengthPenalty(path.length); // 6.8 base
                        return {
                            technique,
                            difficulty: Number(difficulty.toFixed(1)),
                            explanation: `${technique} in house ${house + 1} on ${start.v}`,
                            nodes: [...path],
                            highlights: [
                                ...path.map(p => ({ row: p.r, col: p.c, type: 'hint' as const })),
                                ...elims.map(idx => ({ row: Math.floor(idx / 9), col: idx % 9, type: 'elimination' as const, val: start.v }))
                            ]
                        };
                    }
                }
            }
        }

        if (nextIsStrong) {
            const neighbors = linkMap.get(nodeKey(current)) || [];
            for (const n of neighbors) {
                const nk = nodeKey(n);
                if (!visited.has(nk)) {
                    visited.add(nk);
                    path.push(n);
                    const res = this.search(grid, n, false, path, visited, linkMap, limit);
                    if (res) return res;
                    path.pop();
                    visited.delete(nk);
                }
            }
        } else {
            const cellVals = GridModelV4.getVals(grid.candidates[current.r * 9 + current.c]);
            for (const v of cellVals) {
                if (v === current.v) continue;
                const next = { r: current.r, c: current.c, v };
                const nk = nodeKey(next);
                if (!visited.has(nk)) {
                    visited.add(nk);
                    path.push(next);
                    const res = this.search(grid, next, true, path, visited, linkMap, limit);
                    if (res) return res;
                    path.pop();
                    visited.delete(nk);
                }
            }
            const mask = 1 << (current.v - 1);
            const peers = getPeers(current.r * 9 + current.c);
            for (const p of peers) {
                if (grid.candidates[p] & mask) {
                    const next = { r: Math.floor(p / 9), c: p % 9, v: current.v };
                    const nk = nodeKey(next);
                    if (!visited.has(nk)) {
                        visited.add(nk);
                        path.push(next);
                        const res = this.search(grid, next, true, path, visited, linkMap, limit);
                        if (res) return res;
                        path.pop();
                        visited.delete(nk);
                    }
                }
            }
        }
        return null;
    }
}

// 4. Advanced Chains (Wrappers for common AIC types for better grading)
export class SkyscraperStrategy implements Strategy {
    find(grid: GridModelV4): StepAction | null {
        for (let v = 1; v <= 9; v++) {
            const mask = 1 << (v - 1);
            // 1. Find all rows/cols with exactly 2 of digit V
            const housesWithTwo = [];
            for (let h = 0; h < 18; h++) {
                const cells = HOUSES[h].filter(idx => grid.candidates[idx] & mask);
                if (cells.length === 2) housesWithTwo.push({ h, cells });
            }

            // 2. Look for two parallel houses (both rows or both cols)
            for (let i = 0; i < housesWithTwo.length; i++) {
                for (let j = i + 1; j < housesWithTwo.length; j++) {
                    const h1 = housesWithTwo[i];
                    const h2 = housesWithTwo[j];
                    if ((h1.h < 9 && h2.h < 9) || (h1.h >= 9 && h2.h >= 9)) {
                        // Check if they share a "base" (one pair of ends is in the same col/row)
                        const c1 = h1.cells;
                        const c2 = h2.cells;

                        let baseIdx1 = -1, baseIdx2 = -1;
                        let peakIdx1 = -1, peakIdx2 = -1;

                        if (h1.h < 9) { // Rows
                            if (c1[0] % 9 === c2[0] % 9) { baseIdx1 = c1[0]; baseIdx2 = c2[0]; peakIdx1 = c1[1]; peakIdx2 = c2[1]; }
                            else if (c1[0] % 9 === c2[1] % 9) { baseIdx1 = c1[0]; baseIdx2 = c2[1]; peakIdx1 = c1[1]; peakIdx2 = c2[0]; }
                            else if (c1[1] % 9 === c2[0] % 9) { baseIdx1 = c1[1]; baseIdx2 = c2[0]; peakIdx1 = c1[0]; peakIdx2 = c2[1]; }
                            else if (c1[1] % 9 === c2[1] % 9) { baseIdx1 = c1[1]; baseIdx2 = c2[1]; peakIdx1 = c1[0]; peakIdx2 = c2[0]; }
                        } else { // Cols
                            if (Math.floor(c1[0] / 9) === Math.floor(c2[0] / 9)) { baseIdx1 = c1[0]; baseIdx2 = c2[0]; peakIdx1 = c1[1]; peakIdx2 = c2[1]; }
                            else if (Math.floor(c1[0] / 9) === Math.floor(c2[1] / 9)) { baseIdx1 = c1[0]; baseIdx2 = c2[1]; peakIdx1 = c1[1]; peakIdx2 = c2[0]; }
                            else if (Math.floor(c1[1] / 9) === Math.floor(c2[0] / 9)) { baseIdx1 = c1[1]; baseIdx2 = c2[0]; peakIdx1 = c1[0]; peakIdx2 = c2[1]; }
                            else if (Math.floor(c1[1] / 9) === Math.floor(c2[1] / 9)) { baseIdx1 = c1[1]; baseIdx2 = c2[1]; peakIdx1 = c1[0]; peakIdx2 = c2[0]; }
                        }

                        if (peakIdx1 !== -1) {
                            const elims = getCommonPeers(peakIdx1, peakIdx2).filter(idx => grid.candidates[idx] & mask);
                            if (elims.length > 0) {
                                return {
                                    technique: "Skyscraper",
                                    difficulty: 4.0,
                                    explanation: `Skyscraper on ${v} with peaks at (${Math.floor(peakIdx1 / 9) + 1},${peakIdx1 % 9 + 1}) and (${Math.floor(peakIdx2 / 9) + 1},${peakIdx2 % 9 + 1})`,
                                    highlights: [
                                        { row: Math.floor(peakIdx1 / 9), col: peakIdx1 % 9, type: 'hint' },
                                        { row: Math.floor(peakIdx2 / 9), col: peakIdx2 % 9, type: 'hint' },
                                        ...elims.map(idx => ({ row: Math.floor(idx / 9), col: idx % 9, type: 'elimination' as const, val: v }))
                                    ]
                                };
                            }
                        }
                    }
                }
            }
        }
        return null;
    }
}

export class TwoStringKiteStrategy implements Strategy {
    find(grid: GridModelV4): StepAction | null {
        for (let v = 1; v <= 9; v++) {
            const mask = 1 << (v - 1);
            for (let b = 0; b < 9; b++) {
                const boxCells = HOUSES[b + 18].filter(idx => grid.candidates[idx] & mask);
                if (boxCells.length === 2) {
                    // One kite piece
                    const c1 = boxCells[0], c2 = boxCells[1];
                    const r1 = Math.floor(c1 / 9), col1 = c1 % 9;
                    const r2 = Math.floor(c2 / 9), col2 = c2 % 9;
                    if (r1 !== r2 && col1 !== col2) {
                        // Check row kite
                        const rowCells = HOUSES[r1].filter(idx => grid.candidates[idx] & mask);
                        const colCells = HOUSES[col2 + 9].filter(idx => grid.candidates[idx] & mask);

                        if (rowCells.length === 2 && colCells.length === 2) {
                            const rowEndIdx = rowCells.find(idx => idx !== c1);
                            const colEndIdx = colCells.find(idx => idx !== c2);
                            if (rowEndIdx !== undefined && colEndIdx !== undefined) {
                                const elimIdx = Math.floor(rowEndIdx / 9) * 9 + (colEndIdx % 9);
                                if (grid.candidates[elimIdx] & mask) {
                                    return {
                                        technique: "Two-String Kite",
                                        difficulty: 4.1,
                                        explanation: `Two-String Kite on ${v} connecting box ${b + 1}, row ${r1 + 1}, and col ${col2 + 1}`,
                                        highlights: [
                                            { row: Math.floor(rowEndIdx / 9), col: rowEndIdx % 9, type: 'hint' },
                                            { row: Math.floor(colEndIdx / 9), col: colEndIdx % 9, type: 'hint' },
                                            { row: Math.floor(elimIdx / 9), col: elimIdx % 9, type: 'elimination', val: v }
                                        ]
                                    };
                                }
                            }
                        }

                        // Check other way
                        const rowCells2 = HOUSES[r2].filter(idx => grid.candidates[idx] & mask);
                        const colCells2 = HOUSES[col1 + 9].filter(idx => grid.candidates[idx] & mask);
                        if (rowCells2.length === 2 && colCells2.length === 2) {
                            const rowEndIdx = rowCells2.find(idx => idx !== c2);
                            const colEndIdx = colCells2.find(idx => idx !== c1);
                            if (rowEndIdx !== undefined && colEndIdx !== undefined) {
                                const elimIdx = Math.floor(rowEndIdx / 9) * 9 + (colEndIdx % 9);
                                if (grid.candidates[elimIdx] & mask) {
                                    return {
                                        technique: "Two-String Kite",
                                        difficulty: 4.1,
                                        explanation: `Two-String Kite on ${v} connecting box ${b + 1}, row ${r2 + 1}, and col ${col1 + 1}`,
                                        highlights: [
                                            { row: Math.floor(rowEndIdx / 9), col: rowEndIdx % 9, type: 'hint' },
                                            { row: Math.floor(colEndIdx / 9), col: colEndIdx % 9, type: 'hint' },
                                            { row: Math.floor(elimIdx / 9), col: elimIdx % 9, type: 'elimination', val: v }
                                        ]
                                    };
                                }
                            }
                        }
                    }
                }
            }
        }
        return null;
    }
}

function nodeKey(n: AICNode): string {
    return `${n.r},${n.c},${n.v}`;
}

export const PEERS: number[][] = Array(81).fill(0).map((_, i) => {
    const r = Math.floor(i / 9);
    const c = i % 9;
    const b = Math.floor(r / 3) * 3 + Math.floor(c / 3);
    const peers = new Set<number>();
    for (let j = 0; j < 9; j++) {
        peers.add(r * 9 + j);
        peers.add(j * 9 + c);
    }
    const startR = Math.floor(b / 3) * 3;
    const startC = (b % 3) * 3;
    for (let pr = startR; pr < startR + 3; pr++) {
        for (let pc = startC; pc < startC + 3; pc++) {
            peers.add(pr * 9 + pc);
        }
    }
    peers.delete(i);
    return Array.from(peers);
});

function getPeers(idx: number): number[] {
    return PEERS[idx];
}

function sees(i1: number, i2: number): boolean {
    return PEERS[i1].includes(i2);
}

function getCommonHouse(i1: number, i2: number): number {
    const r1 = Math.floor(i1 / 9);
    const c1 = i1 % 9;
    const b1 = Math.floor(r1 / 3) * 3 + Math.floor(c1 / 3);
    const r2 = Math.floor(i2 / 9);
    const c2 = i2 % 9;
    const b2 = Math.floor(r2 / 3) * 3 + Math.floor(c2 / 3);

    if (r1 === r2) return r1; // Row 0-8
    if (c1 === c2) return c1 + 9; // Col 9-17
    if (b1 === b2) return b1 + 18; // Box 18-26
    return -1;
}

function getCommonPeers(i1: number, i2: number): number[] {
    const p1 = PEERS[i1];
    const p2 = PEERS[i2];
    return p1.filter(p => p2.includes(p));
}

/**
 * Backtracking Solver (Validity Engine)
 */
export class SudokuSolverV4 {
    static solve(puzzle: string | number[][] | number[]): number[][] | null {
        const grid = new GridModelV4(puzzle as any);
        if (this.backtrack(grid)) {
            const result = Array(9).fill(0).map(() => Array(9).fill(0));
            for (let i = 0; i < 81; i++) {
                result[Math.floor(i / 9)][i % 9] = grid.cells[i];
            }
            return result;
        }
        return null;
    }

    static countSolutions(puzzle: string | number[][] | number[], limit: number = 2): number {
        const grid = new GridModelV4(puzzle as any);
        return this.backtrackCount(grid, 0, limit);
    }

    private static backtrack(grid: GridModelV4): boolean {
        let minCandidates = 10;
        let emptyIdx = -1;

        for (let i = 0; i < 81; i++) {
            if (grid.cells[i] === 0) {
                const count = GridModelV4.countSetBits(grid.candidates[i]);
                if (count === 0) return false; // Early exit: unsolvable
                if (count < minCandidates) {
                    minCandidates = count;
                    emptyIdx = i;
                    if (count === 1) break;
                }
            }
        }

        if (emptyIdx === -1) return true;

        const candidates = GridModelV4.getVals(grid.candidates[emptyIdx]);
        for (const v of candidates) {
            const nextGrid = grid.clone();
            nextGrid.setCellValue(emptyIdx, v);
            if (this.backtrack(nextGrid)) {
                grid.cells.set(nextGrid.cells);
                return true;
            }
        }
        return false;
    }

    private static backtrackCount(grid: GridModelV4, count: number, limit: number): number {
        let minCandidates = 10;
        let emptyIdx = -1;

        for (let i = 0; i < 81; i++) {
            if (grid.cells[i] === 0) {
                const cCount = GridModelV4.countSetBits(grid.candidates[i]);
                if (cCount === 0) return count; // Unsolvable path
                if (cCount < minCandidates) {
                    minCandidates = cCount;
                    emptyIdx = i;
                    if (cCount === 1) break;
                }
            }
        }

        if (emptyIdx === -1) return count + 1;

        const candidates = GridModelV4.getVals(grid.candidates[emptyIdx]);
        for (const v of candidates) {
            const nextGrid = grid.clone();
            nextGrid.setCellValue(emptyIdx, v);
            count = this.backtrackCount(nextGrid, count, limit);
            if (count >= limit) return count;
        }
        return count;
    }
}

/**
 * Main Grader Loop
 */

export function gradePuzzleV4(puzzle: string | number[][]): { rating: number; steps: StepAction[]; solved: boolean } {
    const grid = new GridModelV4(puzzle);
    const steps: StepAction[] = [];
    let maxDifficulty = 1.0;

    const strategies: Strategy[] = [
        new HiddenSingleStrategy(),      // 1.2, 1.5
        new PointingStrategy(),           // 2.1
        new NakedSingleStrategy(),        // 2.3
        new ClaimingStrategy(),           // 2.6
        new NakedSubsetStrategy(2),       // 3.0
        new FishStrategy(2),              // 3.2 (X-Wing)
        new HiddenSubsetStrategy(2),      // 3.4
        new NakedSubsetStrategy(3),       // 3.6
        new FishStrategy(3),              // 3.8 (Swordfish)
        new HiddenSubsetStrategy(3),      // 4.0
        new XYWingStrategy(),            // 4.2
        new XYZWingStrategy(),           // 4.4
        new SkyscraperStrategy(),         // 4.0
        new TwoStringKiteStrategy(),      // 4.1
        new UniqueRectangleStrategy(),    // 4.5
        new NakedSubsetStrategy(4),       // 5.0
        new FishStrategy(4),              // 5.2 (Jellyfish)
        new HiddenSubsetStrategy(4),      // 5.4
        new BUGType1Strategy(),           // 5.6
        new AICStrategy(),                // 6.5+
        new CellForcingStrategy(),        // 8.2
    ];

    let safety = 0;
    while (!grid.isSolved() && safety < 100) {
        safety++;
        let found = false;
        for (const strat of strategies) {
            const step = strat.find(grid);
            if (step) {
                step.highlightCells = step.highlights; // Compatibility
                grid.applyStep(step);
                steps.push(step);
                maxDifficulty = Math.max(maxDifficulty, step.difficulty);
                found = true;
                break;
            }
        }
        if (!found) break;
    }

    return { rating: maxDifficulty, steps, solved: grid.isSolved() };
}

// Global class for V2 compatibility
export class SudokuSolverV2 {
    static countSolutions(puzzle: number[][], limit: number = 2): number {
        return SudokuSolverV4.countSolutions(puzzle, limit);
    }
    static solveHuman(puzzle: number[][]) {
        const { rating, steps, solved } = gradePuzzleV4(puzzle);
        return {
            steps,
            solved,
            seRating: rating,
            difficultyLabel: rating < 2.0 ? 'Easy' : rating < 4.0 ? 'Medium' : rating < 6.0 ? 'Hard' : 'Expert',
            hodokuScore: Math.floor(rating * 100) // Rough conversion
        };
    }
}

// Official SE Length Penalty Algorithm from specs/v4-grader-algorithms.md
function getChainLengthPenalty(length: number): number {
    if (length <= 4) return 0.0;
    
    let addedDifficulty = 0.0;
    let ceil = 4;
    let isOddStep = false;
    
    // The loop mimics a logarithmic growth curve specific to SE
    // Thresholds: 4, 6, 9, 12, 18, 24, 36, 48...
    while (length > ceil) {
        addedDifficulty += 0.1;
        
        // The ceiling grows by factor 1.5 approx every step
        if (!isOddStep) {
            ceil = Math.floor(ceil * 3 / 2); // Multiply by 1.5
        } else {
            ceil = Math.floor(ceil * 4 / 3); // Multiply by 1.33
        }
        isOddStep = !isOddStep;
    }
    
    return Number(addedDifficulty.toFixed(1));
}

